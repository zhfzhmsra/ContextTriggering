REFERENCE @"System.Core.dll";


Predict=
SSTREAM @@predictions@@;

Predict =
    SELECT MyHelper.ToUInt(UserId) AS UserId,
           MyHelper.ToUInt(ItemId) AS ItemId,
           Score
    FROM Predict;

//OUTPUT Predict TO SSTREAM @"/users/v-zhoche/Cortana/test.ss";

FastRankLabel=
SSTREAM @@label@@;

result=
SELECT FastRankLabel.QueryId AS UserId,
FastRankLabel.DocId AS ItemId,
FastRankLabel.Rating AS Label,
Predict.Score AS Score
FROM FastRankLabel
INNER JOIN Predict
ON (FastRankLabel.QueryId==Predict.UserId)&&(FastRankLabel.DocId==Predict.ItemId);

evaluate =
    REDUCE result ALL
    PRODUCE Precision,
            Recall,
            F1score,
            Accuracy
    USING MyEvaluate();

OUTPUT evaluate TO SSTREAM @@evaluateresultss@@;
OUTPUT evaluate TO  @@evaluateresult@@;

#CS
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Text;
	using ScopeRuntime;
	using System.Diagnostics;

public class MyEvaluate : Reducer
{
    public override Schema Produces(string[] requested_columns, string[] args, Schema input_schema)
    {
        var outputSchema = new Schema();
  
        outputSchema.Add(new ColumnInfo("Threshold",typeof(double)));
        outputSchema.Add(new ColumnInfo("Precision",typeof(double)));
        outputSchema.Add(new ColumnInfo("Recall",typeof(double)));      
        outputSchema.Add(new ColumnInfo("F1score",typeof(double)));
        outputSchema.Add(new ColumnInfo("Accuracy",typeof(double)));

        return outputSchema;
    }

    public override IEnumerable<Row> Reduce(RowSet input, Row output, string[] args)
    {
        //double threshold=Convert.ToDouble(args[0]);
        

        var rows = new List<Row>();

        foreach (Row row in input.Rows)
        {
            rows.Add(row);
        }

        for (double threshold = 0.05; threshold < 1; threshold += 0.05)
        {
        int pospos=0;
        int negpos=0;
        int posneg=0;
        int negneg=0;
        int sum=0;
        foreach (Row row in rows)
        {
            int label=Convert.ToInt32(row[2].String);
            double score=Convert.ToDouble(row[3].String);
            if (score<threshold) 
            {
                if (label==1) negpos++;
                else negneg++;
            }
            else
            {
                if (label==1) pospos++;
                else posneg++;
            }
            sum++;
        }

        double precision=((double)(pospos))/(pospos+posneg);

        double recall=((double)(pospos))/(pospos+negpos);

        double fscore=2*precision*recall/(precision+recall);

        double accuracy=((double)(pospos+negneg))/sum;

        output["Threshold"].Set(threshold);
        output["Precision"].Set(precision);
        output["Recall"].Set(recall);
        output["F1score"].Set(fscore);
        output["Accuracy"].Set(accuracy);
    
        yield return output;  
        }    
    }
}

public static class MyHelper
{
    public static long ToLong(string x)
    {
        return (long)Convert.ToInt32(x);
    }

    public static uint ToUInt(string x)
    {
        return Convert.ToUInt32(x);
    }

    public static int TimeToSlot(DateTime time)
    {
        int Category;
        int dayofweek = (int)time.DayOfWeek;
        if(dayofweek == 0||dayofweek == 6)
            Category = 1;
        else Category = 0;
        int hour = time.Hour;
          
        return (24*Category+ hour);
    }
 
    public static int Year(DateTime time)
    {
        return time.Year;
    }
    
    public static int Month(DateTime time)
    {
        return time.Month;
    }
}

#ENDCS

// Generated by ScopeStudio, version 1.8.0000.3!
